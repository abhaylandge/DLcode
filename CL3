#Prac6
6.Implement Ant colony optimization on travelling salesman problem.

#import libraries
import numpy as np
import random

#initialize distance matrix
# 4 cities
distance_matrix = np.array([
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
])

#initialize params
num_ants = 10
num_iterations = 50
evaporation_rate = 0.5 
pheromone_constant = 1.0
heuristic_constant = 1.0

num_cities = len(distance_matrix)
num_cities
----------

#initialize pheromone matrix to 1s
pheromone = np.ones((num_cities, num_cities))

#initialize visibility matrix (inverse of distance matrix)
visibility = 1 / distance_matrix

----

visibility

------

#ACO algorithm

for i in range(num_iterations):
    #will store the routes generated by the ants during curr iteration
    ant_routes = []
    
    #for each ant
    for ant in range(num_ants):
        
        #a random city is chosen
        current_city = random.randint(0, num_cities-1) # chooses random number between 0 and 3
        
        visited_cities = [current_city]
        route = [current_city]
        
        #checks if ant has visited all cities or not
        while len(visited_cities) < num_cities:
            
            #prob of selecting each unvisited city as next destination
            probabilities = []
            
            for city in range(num_cities):
                
                if city not in visited_cities:
                    
                    #retrieve the current pheromone level on the edge connecting the cities
                    pheromone_value = pheromone[current_city][city]
                    
                    #this retrieves the visibility or attractiveness of the edge
                    visibility_value = visibility[current_city][city]
                    
                    #calculate the probability of selecting current city as next destination
                    probability = (pheromone_value ** pheromone_constant) * (visibility_value ** heuristic_constant)
                    
                    probabilities.append((city, probability))
                    
            #sorted based on descending order of probabilities        
            probabilities = sorted(probabilities, key=lambda x: x[1], reverse = True)
            
            #after sorting, first tuple contains highest prob city so select it
            selected_city = probabilities[0][0]
            
            route.append(selected_city)
            visited_cities.append(selected_city)
            current_city = selected_city
        
        ant_routes.append(route)
    
    #Update pheromones
    #initialize a matrix with 0s
    delta_pheromone = np.zeros((num_cities, num_cities))
    
    #iterate over each ant's route
    #enumerate() = used to get both the index of ant and its coressponding route
    for ant,route in enumerate(ant_routes):
        
        for i in range(len(route) - 1):
            city_a = route[i]
            city_b = route[i+1]
            
            #increment the amount of pheromones to be deposited
            #it is inverse of distance i.e shorter path will get more pheromones
            delta_pheromone[city_a][city_b] += 1/distance_matrix[city_a][city_b]
            delta_pheromone[city_b][city_a] += 1/distance_matrix[city_a][city_b]
    
    #finally update pheromone levels
    pheromone = (1 - evaporation_rate) * pheromone + delta_pheromone

---------

# Initialize variables
best_distance = float('inf')
best_route = None

# Iterate through each route in ant_routes
for route in ant_routes:
    total_distance = 0
    
    # Calculate total distance for current route
    for i in range(num_cities):
        total_distance += distance_matrix[route[i]][route[(i + 1) % num_cities]]
    
    # Check if current route has the shortest distance
    if total_distance < best_distance:
        best_distance = total_distance
        best_route = route

# Output best route and shortest distance
print("Best Route:", best_route)
print("Shortest Distance:", best_distance)

-----------
